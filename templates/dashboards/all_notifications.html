{% extends 'dashboards/student_base.html' %}
{% load static %}
{% load humanize %}

{% block extra_css %}
    <link rel="stylesheet" href="{% static 'css/all_notifications.css' %}?v=1.2">
{% endblock %}

{% block content %}
<div class="notifications-page-container">
    <div class="notifications-card">

        <div class="notifications-header">
            <h1 class="card-title">Notifications</h1>
            <div class="header-controls">
                <div class="tabs">
                    <button type="button" class="tab-btn active" data-tab="all">All</button>
                    <button type="button" class="tab-btn" data-tab="unread">Unread</button>
                    <button type="button" class="btn-mark-all" id="mark-all-read-btn">
                        Mark all as read
                </button>
                </div>
            </div>
        </div>

        <div class="notification-list" id="notification-list-main">
            {% for notification in all_notifications %}
                <div class="notification-item-row" 
                     data-id="{{ notification.id }}" 
                     data-read="{{ notification.is_read|yesno:'true,false' }}"
                     data-url="{% url 'mark_notification_read_and_redirect' notification.id %}">
                    
                    <input type="checkbox" class="notification-checkbox" value="{{ notification.id }}">
                    
                    <img src="{{ notification.product_image_url|default:'https://placehold.co/400x300/e0e7ff/3730a3?text=Item' }}" 
                         alt="Product" class="product-image">
                    
                    <div class="notification-content">
                        <p class="notification-message">{{ notification.message }}</p>
                        <span class="notification-time">{{ notification.created_at|timesince }} ago</span>
                    </div>
                    
                    {% if not notification.is_read %}
                        <div class="unread-dot" title="Unread"></div>
                    {% endif %}
                </div>
            {% endfor %}

                <div class="empty-state" id="static-empty-state" {% if all_notifications %}style="display: none;"{% endif %}>
                    <div class="empty-state-icon"><i class="fa-solid fa-check"></i></div>
                    <h3>All clear!</h3>
                    <p>You have no notifications right now.</p>
                </div>
            

                <div class="empty-state" id="filter-empty-state" style="display: none;">
                <div class="empty-state-icon"><i class="fa-solid fa-magnifying-glass"></i></div>
                <h3>No notifications found</h3>
                <p>No notifications match this filter.</p>
            </div>
        </div>

    </div>
</div>

<div class="action-bar" id="action-bar">
    

    <div class="select-all-container">
        <input type="checkbox" id="select-all-checkbox">
        <label for="select-all-checkbox">Select All</label>
    </div>

    <div class="action-buttons">
        <button type="button" class="btn btn-secondary" id="mark-read-btn" data-action="mark_read">Mark as Read</button>
        <button type="button" class="btn btn-secondary" id="mark-unread-btn" data-action="mark_unread">Mark as Unread</button>
        <button type="button" class="btn btn-danger" id="delete-btn">Delete</button>
    </div>
</div>

<div id="batch-delete-confirm-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Confirm Deletion</h2>
            <span class="close-btn" data-close-modal="batch-delete-confirm-modal">&times;</span>
        </div>
        <div class="modal-body">
            <h3>Are you sure?</h3>
            <p>This will permanently delete the selected notifications. This action cannot be undone.</p>
        </div>
        <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-close-modal="batch-delete-confirm-modal">Cancel</button>
            <button type="button" class="btn btn-danger" id="confirm-delete-btn">Yes, Delete</button>
        </div>
    </div>
</div>

{% endblock %}


{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const listContainer = document.getElementById('notification-list-main');
    const allNotificationRows = listContainer.querySelectorAll('.notification-item-row');
    const actionBar = document.getElementById('action-bar');
    const selectAllCheckbox = document.getElementById('select-all-checkbox');
    const tabButtons = document.querySelectorAll('.tab-btn');
    const markReadBtn = document.getElementById('mark-read-btn');
    const markUnreadBtn = document.getElementById('mark-unread-btn');
    const deleteBtn = document.getElementById('delete-btn');
    const loader = document.getElementById('page-loader'); // Get the page loader
    const deleteModal = document.getElementById('batch-delete-confirm-modal');
    const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
    const markAllReadBtn = document.getElementById('mark-all-read-btn');

    let currentTab = 'all'; // Default tab

    // --- Helper: Get CSRF Token ---
    function getCsrfToken() {
        // Find the token in the form. Fallback to cookies if needed.
        let tokenInput = document.querySelector('form [name=csrfmiddlewaretoken]');
        if (tokenInput) return tokenInput.value;
        
        // Fallback logic from student_base.html
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, 10) === 'csrftoken=') {
                    return decodeURIComponent(cookie.substring(10));
                }
            }
        }
        return '';
    }

    // --- Update Header Count ---
    function updateHeaderCount(newCount) {
        const bellButton = document.getElementById('notification-bell-btn');
        if (!bellButton) return;

        let countElement = bellButton.querySelector('.notification-count');

        if (newCount > 0) {
            if (!countElement) {
                countElement = document.createElement('span');
                countElement.className = 'notification-count';
                bellButton.appendChild(countElement);
            }
            countElement.textContent = newCount;
        } else {
            // If the new count is 0, remove the element
            if (countElement) {
                countElement.remove();
            }
        }
    }

    // --- Helper: Show/Hide Empty State ---
    function checkEmptyState() {
        // First, get a count of ALL notification rows, visible or not
        const totalRows = listContainer.querySelectorAll('.notification-item-row').length;
        // Next, get a count of only the VISIBLE rows (matching the filter)
        const visibleRows = listContainer.querySelectorAll('.notification-item-row:not([style*="display: none"])').length;
        
        const staticEmptyState = document.getElementById('static-empty-state');
        const filterEmptyState = document.getElementById('filter-empty-state');

        if (totalRows === 0) {
            if (staticEmptyState) {
                staticEmptyState.style.display = 'block';
            }
            if (filterEmptyState) {
                filterEmptyState.style.display = 'none';
            }
        } else {
            if (staticEmptyState) {
                staticEmptyState.style.display = 'none';
           }
            
            if (visibleRows === 0) {
                if (filterEmptyState) {
                    filterEmptyState.style.display = 'block';
                }
            } else {
                if (filterEmptyState) {
                    filterEmptyState.style.display = 'none';
                }
            }
        }
    }
    // --- Tab Switching Logic ---
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            currentTab = button.dataset.tab;
            
            allNotificationRows.forEach(row => {
                const isRead = row.dataset.read === 'true';
                if (currentTab === 'all' || (currentTab === 'unread' && !isRead)) {
                    row.style.display = 'flex'; // Use 'flex' to match CSS
                } else {
                    row.style.display = 'none';
                }
            });
            
            selectAllCheckbox.checked = false;
            allNotificationRows.forEach(row => row.querySelector('.notification-checkbox').checked = false);
            updateActionBar();
            checkEmptyState();
        });
    });

    // --- Action Bar & Checkbox Logic ---
    function updateActionBar() {
        const visibleCheckboxes = listContainer.querySelectorAll('.notification-item-row:not([style*="display: none"]) .notification-checkbox');
        const checkedCheckboxes = listContainer.querySelectorAll('.notification-item-row:not([style*="display: none"]) .notification-checkbox:checked');
        
        const checkedCount = checkedCheckboxes.length;
        
        if (checkedCount > 0) {
            actionBar.classList.add('is-active');
            document.body.classList.add('action-bar-visible');
            
            // Check what types of items are selected
            const hasUnread = Array.from(checkedCheckboxes).some(cb => cb.closest('.notification-item-row').dataset.read === 'false');
            const hasRead = Array.from(checkedCheckboxes).some(cb => cb.closest('.notification-item-row').dataset.read === 'true');

            // Show/hide buttons based on selection
            markReadBtn.style.display = hasUnread ? 'inline-block' : 'none';
            markUnreadBtn.style.display = hasRead ? 'inline-block' : 'none';
            deleteBtn.style.display = 'inline-block'; // Show delete if anything is selected

        } else {
            actionBar.classList.remove('is-active');
            document.body.classList.remove('action-bar-visible');
        }
        
        // Update "Select All" checkbox state
        selectAllCheckbox.checked = visibleCheckboxes.length > 0 && checkedCheckboxes.length === visibleCheckboxes.length;
    }

    // "Select All" click
    selectAllCheckbox.addEventListener('change', () => {
        const isChecked = selectAllCheckbox.checked;
        // Selector now correctly checks for rows that are NOT hidden
        listContainer.querySelectorAll('.notification-item-row:not([style*="display: none"]) .notification-checkbox').forEach(cb => {
            cb.checked = isChecked;
        });
        updateActionBar();
    });

    // Individual checkbox click
    listContainer.addEventListener('change', e => {
        if (e.target.classList.contains('notification-checkbox')) {
            updateActionBar();
        }
    });

    listContainer.addEventListener('click', e => {
        // Don't run if we clicked the checkbox
        if (e.target.classList.contains('notification-checkbox')) {
            return;
        }
        
        const row = e.target.closest('.notification-item-row');
        if (row) {
            const url = row.dataset.url;
            if (!url) return;

            // Show the page loader immediately
            if (loader) loader.classList.add('visible');

            // Call the "mark as read" view using FETCH POST
            fetch(url, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => response.json())
            .then(data => {
                // Redirect to the URL from the response
                if (data.redirect_url) {
                    window.location.href = data.redirect_url;
                } else {
                    window.location.href = "{% url 'my_orders' %}"; // Fallback
                }
            })
            .catch(error => {
                console.error('Error marking notification as read:', error);
                window.location.href = "{% url 'my_orders' %}"; // Fallback
            });
        }
    });

    // --- AJAX Action Button Clicks ---
    async function handleBatchAction(action, button) {
        const checkedIds = Array.from(listContainer.querySelectorAll('.notification-item-row:not([style*="display: none"]) .notification-checkbox:checked')).map(cb => cb.value);
        if (checkedIds.length === 0) return;

        
        const url = (action === 'delete') ? "{% url 'batch_delete_notifications' %}" : "{% url 'batch_update_notifications' %}";
        const formData = new FormData();
        formData.append('notification_ids', checkedIds.join(','));
        formData.append('action', action); // 'mark_read', 'mark_unread', or 'delete'
        
        button.disabled = true;
        button.textContent = 'Processing...';

        try {
            const response = await fetch(url, {
                method: 'POST',
                body: formData,
                headers: { 'X-CSRFToken': getCsrfToken(), 'X-Requested-With': 'XMLHttpRequest' }
            });
            const data = await response.json();
            if (!data.success) throw new Error(data.error);

            if (data.new_unread_count !== undefined) {
                updateHeaderCount(data.new_unread_count);
            }
            
            // Success! Update the UI
            checkedIds.forEach(id => {
                const row = listContainer.querySelector(`.notification-item-row[data-id="${id}"]`);
                if (row) {
                    if (action === 'delete') {
                        row.remove();
                    } else {
                        const newReadState = (action === 'mark_read');
                        row.dataset.read = newReadState ? 'true' : 'false';
                        const dot = row.querySelector('.unread-dot');
                        if (newReadState) {
                            if (dot) dot.remove();
                        } else {
                            if (!dot) {
                                const newDot = document.createElement('div');
                                newDot.className = 'unread-dot';
                                newDot.title = 'Unread';
                                row.appendChild(newDot);
                            }
                        }
                    }
                }
            });

        } catch (error) {
            console.error('Batch action failed:', error);
            alert('An error occurred. Please try again.');
        } finally {
            // Reset UI
            selectAllCheckbox.checked = false;
            allNotificationRows.forEach(row => {
                const cb = row.querySelector('.notification-checkbox');
                if (cb) cb.checked = false;
            });
            updateActionBar(); 

            if (deleteModal) deleteModal.style.display = 'none';

            if (currentTab === 'unread' && action === 'mark_read') {
                checkedIds.forEach(id => {
                    const row = listContainer.querySelector(`.notification-item-row[data-id="${id}"]`);
                    if (row) {
                        row.style.display = 'none';
                    }
                });
            }
       
            checkEmptyState();
            // Reset button states
            markReadBtn.disabled = false;
            markReadBtn.textContent = 'Mark as Read';
            markUnreadBtn.disabled = false;
            markUnreadBtn.textContent = 'Mark as Unread';
            deleteBtn.disabled = false;
            deleteBtn.textContent = 'Delete';
            confirmDeleteBtn.disabled = false;
            confirmDeleteBtn.textContent = 'Yes, Delete';
        }
    }

    // --- "MARK ALL READ" FUNCTION ---
    async function handleMarkAllRead() {
        const hasUnread = listContainer.querySelector('.notification-item-row[data-read="false"]');
        if (!hasUnread) {
            console.log("No unread items to mark as read.");
            return; // Stop the function
        }
        markAllReadBtn.disabled = true;
        markAllReadBtn.textContent = 'Processing...';
        
        try {
            const response = await fetch("{% url 'mark_all_as_read' %}", {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });
            
            const data = await response.json();
            if (!data.success) throw new Error(data.error);

            // Update header count
            if (data.new_unread_count !== undefined) {
                updateHeaderCount(data.new_unread_count);
            }

            // Update all visible items on the page
            allNotificationRows.forEach(row => {
                row.dataset.read = 'true';
                const dot = row.querySelector('.unread-dot');
                if (dot) dot.remove();
                
                // If on "Unread" tab, hide the row
                if (currentTab === 'unread') {
                    row.style.display = 'none';
                }
            });
            
            // Update the empty state message
            checkEmptyState();
        } catch (error) {
            console.error('Mark all as read failed:', error);
            alert('An error occurred. Please try again.');
        } finally {
            // Reset the button
            markAllReadBtn.disabled = false;
            markAllReadBtn.textContent = 'Mark all as read';
        }
    }


    // Attach listeners
    markReadBtn.addEventListener('click', () => handleBatchAction('mark_read', markReadBtn));
    markUnreadBtn.addEventListener('click', () => handleBatchAction('mark_unread', markUnreadBtn));

    if (markAllReadBtn) {
        markAllReadBtn.addEventListener('click', handleMarkAllRead);
    }

    // When "Delete" in the action bar is clicked, show the modal
    deleteBtn.addEventListener('click', () => {
        if (deleteModal) deleteModal.style.display = 'flex';
    });

    // When "Yes, Delete" in the modal is clicked, run the action
    confirmDeleteBtn.addEventListener('click', () => {
        handleBatchAction('delete', confirmDeleteBtn);
    });

    // Add listeners to all "Cancel" (close) buttons on the modal
    if (deleteModal) {
        deleteModal.querySelectorAll('[data-close-modal]').forEach(btn => {
            btn.addEventListener('click', () => {
                deleteModal.style.display = 'none';
            });
        });
    }


    // Initial setup
    checkEmptyState();
});
</script>
{% endblock %}